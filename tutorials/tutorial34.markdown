---
title: Урок 34 - GLFX - An OpenGL Effect Library
---
<a href="http://ogldev.atspace.co.uk/www/tutorial34/tutorial34.html"><h2>Теоретическое введение</h2></a>

<p>
Этот урок слегка отличается от предыдущих. Вместо изучения возможностей технологий OpenGL мы собираемся рассмотреть GLFX, библиотеку эффектов OpenGL. <i>Эффект</i> - это текстовый файл, который, возможно, содержит несколько шейдеров и упрощает комбинирование их в программе. Это позволяет обойти ограничение функции glShaderSource(), которая требует указать текст только одного этапа шейдеров. Она насильно заставляет использовать различные текстовые файлы для каждого шейдера (или различные буферы, как мы делали в прошлых уроках). Помещение всех шейдеров в один файл упрощает обмен определением структур между ними. Кроме того, GLFX предоставляет простой API для перевода эффектов в программу GLSL, что частично скрывает сложность функций OpenGL.
</p>
<p>
Идея файлов эффектов не нова. На самом деле, Microsoft уже годами раннее реализовало это в мире DirectX. Я уверен, что игровые студии имеют их собственный инструментарий, но к стыду говорят, в OpenGL нет для этого стандарта. Библиотека эффектов, которую мы будем использовать, - свободный проект Max Aizenshtein. Домашняя страница библиотеки <a href="http://code.google.com/p/glfx/">тута</a>.
</p>
<p>
Существует 2 способа установки GLFX. Если вы используете Ubuntu, то вы можете просто установить deb пакет из моего ppa на launchpad.net, или вы можете скачать исходный код и собрать самостоятельно.
</p>
<h3>Способ 1 - установка пакета GLFX для Ubuntu</h3>
<ul>
<li>Для начала, вы должны добавить мой ppa к списку источников apt. Это можно сделать 2 способами:</li>
<ul>
<li>Запустить в терминале 'add-apt-repository ppa:etay-meiri/ppa'.</li>
<li>Или вы можете вручную добавить следующий репозиторий /etc/apt/sources.list:</li>
<ul>
<li>deb http://ppa.launchpad.net/etay-meiri/ppa/ubuntu oneiric main</li>
<li>deb-src http://ppa.launchpad.net/etay-meiri/ppa/ubuntu oneiric main</li>
</ul>
</ul>
<li>Запустить 'apt-get update'</li>
<li>А затем 'apt-get install libglfx'</li>

</ul>
<h3>Способ 2 - установка из исходников</h3>
<p>
Получаем исходники и собираем их с помощью следующих команд:
</p>
<ul>
<li>svn checkout http://glfx.googlecode.com/svn/trunk/ libglfx</li>
<li>cd libglfx</li>
<li>./configure --prefix=/usr</li>
<li>make</li>
<li>make install   (as root)</li>
</ul>
<p>
<b><u>Внимание</u></b>: GLFX зависит от GLEW. В этом нет проблемы, если вы используете эти уроки как фреймворк или ранее использовали GLEW в своем приложении. Если нет, то вернитесь в <a href="http://ogltutor.netau.net/tutorial02.html">2 урок</a> для информации об инициализации GLEW.
</p>

<a href="https://github.com/triplepointfive/ogldev/tree/master/tutorial34"><h2>Прямиком к коду!</h2></a>


<h3>Внедрении GLFX в проект</h3>
<p>
Добавьте следующее для получения доступа к api GLFX:
</p>
<pre><code>#include &lt;glfx.h&gt;
</code></pre>
<p>
Создание указателя на эффект:
</p>
<pre><code>int effect = <b>glfxGenEffect</b>();
</code></pre>
<p>
Проход по файлу эффекта (мы получим его содержание мгновенно):
</p>
<pre><code>if (!<b>glfxParseEffectFromFile</b>(effect, "effect.glsl")) {
#ifdef __cplusplus	// C++ error handling
	std::string log = <b>glfxGetEffectLog</b>(effect);
	std::cout &lt;&lt; "Error parsing effect: " &lt;&lt; log &lt;&lt; std::endl;
#else	// C error handling
	char log[10000];
	<b>glfxGetEffectLog</b>(effect, log, sizeof(log));
	printf("Error parsing effect: %s:\n", log);
#endif
	return;
}
</code></pre>
<p>
Компилирование программы (комбинация из VS, FS и прочих) определяется в файле эффекта следующим образом:
</p>
<pre><code>int shaderProg = <b>glfxCompileProgram</b>(effect, "ProgramName");
    
if (shaderProg &lt; 0) {
	// таже ошибка с указателем, что и ранее
}
</code></pre>
<p>
Теперь программа может быть использована в OpenGL как обычно:
</p>
<pre><code>glUseProgram(shaderProg);
</code></pre>
<p>
Так как эффект больше не требуется, то удаляем его через
</p>
<pre><code><b>glfxDeleteEffect</b>(effect);
</code></pre>
<h3>Использование GLFX</h3>
<p>
Теперь у нас есть базовая инфраструктура, поэтому давайте погрузимся в файлы эффекта. Прелесть GLFX в том, что вы можете продолжить писать шейдеры GLSL практически в том же стиле, что и ранее. Есть несколько отличий, на которых мы фокусируемся.
</p>
<p>
<b>
Добавился раздел 'program' для комбинации этапов шейдеров в полной программе GLSL.
</b>
</p>
<pre><code>program Lighting
{
	vs(410)=VSmain();
	fs(410)=FSmain();
};
</code></pre>
<p>
В примере выше файл эффекта где-то содержит определение функций VSmain() и FSmain(). Раздел 'program' определяет программу OpenGL с названием 'Lighting'. Вызов glfxCompileProgram(effect, "Lighting") приведет к компиляции и линковки VSmain() и FSmain() в единую программу. Оба шейдера будут компилироваться в GLSL версии 4.10 (аналогично объявлению '#version 410' в обычном GLSL). 
</p>
<p>
<b>
Использование 'shader' вместо 'void' для объявления главной функции шейдера.
</b>
</p>
<p>
Главная точка входа в шейдер должна быть объявлена как 'shader' вместо 'void'. Вот пример:</p>
<pre><code><b>void</b> calculate_something()
{
	...
}

<b>shader</b> VSmain()
{
	calculate_something();
}
</code></pre>
<p>
<b>
Включение нескольких шейдеров и программ в единый файл эффекта.
</b>
</p>
<p>
Вы можете разместить несколько разделов 'program' в единственный файл эффекта. Просто вызовете glfxCompileProgram() для каждой программы, которую хотите использовать. 
</p>
<p>
<b>
Использование структур для передачи вершинных атрибутов между этапами шейдеров.
</b>
</p>
<p>
Вместо определения in/out переменных в глобальной секции шейдера мы можем использовать структуру GLSL и обмениваться ей между несколькими этапами шейдеров. Вот пример:
</p>
<pre><code>struct VSInput 
{
	vec3 Position;                                             
	vec2 TexCoord;                                             
	vec3 Normal;                                               
};

struct VSoutput
{
	vec2 TexCoord;                                             
	vec3 Normal;                                               
};

shader VSmain(in VSInput VSin, out <b>VSOutput</b> VSout)
{                                                                                   
	// преобразуем 'VSin' и обновляем 'VSout'
}

shader FSmain(in <b>VSOutput</b> FSin, out vec4 FragColor)
{
	// 'FSin' соответствует 'VSout' из VS. используем ее
	// для вычисления света и записываем результат в 'FragColor'
}
</code></pre>
<p>
<b>
Использование включений для обмена функционалом между файлами эффектов.
</b>
</p>
<p>
Ключевое слово 'include' может быть использовано для включения одного файла эффекта в другой:
</p>
<pre><code>#include "another_effect.glsl"
</code></pre>
<p>
Предостережение с включением файлов в том, что они не пробегаются GLFX. Они просто добавляются как есть в место, указанное словом 'include'. Это значит, что вы можете поместить только чисто GLSL код в них, без GLFX. Совет: поскольку часть синтаксиса GLSL аналогична C/C++ (#define), вы можете даже обмениваться определениями между файлом эффекта и вашем приложением.
</p>
<p>
<b>
Использование суффикса структур для определения позиции атрибута
</b>
</p>
<p>
В прошлых уроках мы использовали ключевое слова 'layout(location = ...)' для определения позиции входящего атрибута в VS. Поместив двоеточие перед числом после входящего параметра VS мы можем достичь того же эффекта. Вот пример:
</p>
<pre><code>struct VSInput1 
{
	vec3 Position;                                             
	vec2 TexCoord;                                             
};

struct VSInput2 
{
	vec3 Normal;                                               
	vec3 Tangent;                                               
};

shader VSmain(in VSInput1 VSin : 5, in float colorScale : 10, in VSInput2 : 12)
</code></pre>
<p>
VS выше получает позицию в атрибуте 5, координаты текстуры в 6, цвет в 10, нормаль в 12 и тангент в 13. Идея крайне проста - число после двоеточия определяет его позицию. В случае структур вы определяете позицию только первого атрибута. Остальные будут получать следующие значения согласно их типу (т.е. вектор возьмет 1 атрибут, а матрица 4x4 - 4 атрибута). Если суффикс отсутствует, то отсчет начнется с 0.
</p>
<p>
<b>
Использование 'interface' вместо 'struct' для размещения квалификаторов
</b>
</p>
<p>
GLSL предоставляет несколько квалификаторов, такие как 'flat' и 'noperspective', которые могут быть размещены перед атрибутами, которые посылаются из VS в FS. Эти квалификаторы не могут быть использованы для членов структур. Решение, которое предоставляет GLFX - новое ключевое слово 'interface', которое позволяет то, что 'struct' не может. 'interface' может быть только передан между этапами шейдеров. Если вам требуется передать его целиком в другую функцию, то вы должны копировать его содержимое в структуру. Пример:
</p>
<pre><code>interface foo
{
	<b>flat</b> int a;
	<b>noperspective</b> float b;
};

struct bar
{
	int a;
	float b;
}

shader VSmain(out foo f)
{
	// ...
}

void Calc(bar c)
{
	// ...
}

shader FSmain(in foo f)
{
		struct bar c;
		c.a = f.a;
		c.b = f.b;

		Calc(c);
}
</code></pre>
<p>
<b>Внимание:</b> 'interface' - это ключевое слово, зарезервированное на будущее (согласно OpenGL 4.2). Его использование в GLFX будет зависеть от изменений в спецификации OpenGL.
</p>
<p>
<b>
Совет: используйте 'glfxc' для проверки файлов эффектов</b>
</p>
<p>
'glfxc' - это приложение, часть GLFX. Он проходит по файлу эффекта, компилирует его и сообщит об ошибках. Запускается от так:
</p>
<pre><code>glfxc &lt;effect file name&gt; &lt;program name&gt;
</code></pre>
<hr>
<h3>Демо</h3>
<p>
Код этого урока был изменен для работы с GLFX. Поскольку изменения незначительны, я не буду показывать их. Лучше посмотрите на исходники классов Technique и LightingTechnique. Кроме того, шейдеры, который используются в 'lighting_technique.cpp', были перемещены в файл эффекта, названный 'lighting.glsl' в папке 'shaders'. Этот файл содержат те же шейдеры; вы уже знакомы с ними. Они были слегка изменены согласно правилам выше.
</p>
