---
title: Урок 10 - Индексированная отрисовка
---
<a href="http://ogldev.atspace.co.uk/www/tutorial10/tutorial10.html"><h2>Теоретическое введение</h2></a>

<p>OpenGL предоставляет несколько функций отрисовки. glDrawArrays(), которую мы использовали до этого урока, находится в категории "порядковой отрисовки". Это означает, что вершинный буфер сканируется от начала указанного смещения и каждые X вершин (1 для точек, 2 для линии и т.д.) становятся примитивом. Такой подход прост в использовании, но минус в том, что если вершина участвует в нескольких примитивах, то она должна содержаться в вершинном буфере несколько раз. То есть, нет никакой концепции обмена. Обмен обеспечивают функций отрисовки из категории "индексированной отрисовки". В дополнении к вершинному буферу используется буфер индексов, содержащий индексы вершин в вершинном буфере. Обработка индексированного буфера аналогична вершинному - каждые X индексов образуют примитив. Для осуществления обмена вы просто повторяете индекс требуемой вершины несколько раз. Обмен очень важен для экономии памяти потому, что большая часть объектов представлена в виде замкнутой сетки из треугольников, и почти все вершины 
образуют более одного треугольника.</p>
<p>Вот пример порядковой отрисовки:</p>
<img style="width: 600px; height: 100px;" alt="" src="/images/t10_ordered_draw.png">
<p>Если нам нужны треугольники, то GPU генерирует следующий набор: V0/1/2, V3/4/5, V6/7/8 и т.д.</p>
<p>А вот пример индексированной отрисовки:</p>
<img style="width: 600px; height: 300px;" alt="" src="/images/t10_indexed_draw.png">
<p>В этом случае GPU создаст следующие треугольники: V4/0/1, V5/2/1, V6/1/7 и т.д.</p>
<p>Использование такой отрисовки в OpenGL требует создания и заполнения буфера индексов. Этот буфер должен быть указан вместе с вершинным до вызова функции отрисовки, а так же необходимо использовать другое API.</p>
<a href="https://github.com/triplepointfive/ogldev/tree/master/tutorial10"><h2>Прямиком к коду!</h2></a> 

<pre><code>GLuint IBO;</code></pre>

<p>Мы добавляем еще один указатель на буферный объект для буфера индексов.</p>

<pre><code>Vertices[0] = Vector3f(-1.0f, -1.0f, 0.0f);
Vertices[1] = Vector3f(0.0f, -1.0f, 1.0f);
Vertices[2] = Vector3f(1.0f, -1.0f, 0.0f);
Vertices[3] = Vector3f(0.0f, 1.0f, 0.0f);</code></pre>

<p>Для демонстрации обмена нам потребуется более сложная фигура. Во многих уроках для этого используется куб. Для него потребуются 8 вершин и 12 треугольников. Но так как я ленивый, у нас будет вращающаяся пирамида. Ей потребуется всего 4 вершины и 4 треугольника, это гораздо проще для написания вручную...</p>
<p>Если смотреть на эти вершины сверху (вдоль оси Y), мы увидим такое расположение:</p>
<img style="width: 816px; height: 500px;" alt="" src="/images/t10_pyramid.png"><br>

<pre><code>unsigned int Indices[] = { 0, 3, 1,
                           1, 3, 2,
                           2, 3, 0,
                           0, 2, 1 };</code></pre>
                           
<p>Буфер индексов заполняется с помощью массива индексов. Индексы указывают на расположение вершин в вершинном буфере. Если смотреть на массив и чертеж выше, то вы заметите, что последний треугольник - основание пирамиды, остальные же - ее грани. Пирамида не симметрична, но это легко исправляется.</p>

<pre><code>glGenBuffers(1, &amp;IBO);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);</code></pre>

<p>Мы создаем, а затем заполняем буфер индексов используя массив индексов. Вся разница в создании вершинного и индексного буферов в том, что для первого мы указываем GL_ARRAY_BUFFER, а для второго - GL_ELEMENT_ARRAY_BUFFER. </p>

<pre><code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);</code></pre>

<p>В дополнении к привязыванию вершинного буфера мы делаем то же самое с индексным. И, мы снова используем GL_ELEMENT_ARRAY_BUFFER в качестве типа буфера.</p>

<pre><code>glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, 0);</code></pre>

<p>Мы используем glDrawElements вместо glDrawArrays. Первый параметр - это тип примитивов (так же, как и у glDrawArrays). Второй параметр указывает какое количество индексов в индексном буфере будет использоваться. Следующий параметр - тип переменных в буфере индексов. GPU обязан знать размер каждого индекса, иначе он не сможет получить индексы из буфера. Возможные варианты: GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT. Если индексы малы, то вы захотите выбрать наименьший тип для экономии памяти и наоборот, в случае больших индексов требуются большие типы. Последний параметр передает GPU смещение в байтах от начала буфера индексов до до позиции первого индекса для обработки. Это полезно, когда один буфер индексов содержит индексы многих объектов. Указывая смещение и количество индексов возможно показать GPU какой объект рендерить. Мы хотим начать с начала, поэтому указываем 0. Заметим, что тип последнего параметра GLvoid*, поэтому если мы указываем что-либо отличное от 0, то необходимо 
преобразовать в этот тип.</p>