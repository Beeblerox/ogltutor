---
title: Урок 14 - Управление камерой - часть 1
---

<p>В предыдущем уроке мы разобрались как установить камеру в любую точку 3D пространства. Следующий этап - это дать возможность пользователю управлять ей. Управление будет свободным - пользователь может двигать ее во всех направлениях. Управление камерой будет осуществляться 2 устройствами ввода: клавиатурой мы будем изменять позицию, а мышью направление обзора. Это очень похоже на то, что предлагают шутеры от первого лица. Этот урок сфокусируется на клавиатуре, а следующий - на мышке.</p>
<p>Мы добавим поддержку 4 клавиш в привычном виде. Вспомним, что наша камера определяется ее позицией, вектором направления и верхним вектором. Когда мы используем клавиатуру меняется только позиция. Мы не можем наклонить или повернуть камеру, а значит, что векторы вверх и направления останутся не низменными.</p>
<p>Для использования клавиатуры нам потребуется другой API GLUT'a: glutSpecialFunc(). Эта функция записывает нашу для вызова, если будет нажата "специальная" клавиша. В группу специальных клавиш входят: F{1..12}, стрелки и PAGE-UP / PAGE-DOWN / HOME / END / INSERT. Если вам нужны обычные кнопки (символы и цифры) используйте glutKeyboardFunc().</p> 
<a href="https://github.com/triplepointfive/ogldev/tree/master/tutorial14"><h2>Прямиком к коду!</h2></a>
<p>Функционал камеры инкапсулирован в классе камеры. Этот класс хранит параметры камеры и может их изменять основываясь на событиях движения, которые он получит. Атрибуты камеры будут перехвачены классом конвейера, а тот уже и создаст матрицу преобразований из них.</p>
</div></article><article class="hero clearfix"><div class="col_33">
<p class="message">Camera.h</p>
</div></article><article class="hero clearfix"><div class="col_100">
<pre><code>class Camera
{
public:
	Camera();
	Camera(const Vector3f&amp; Pos, const Vector3f&amp; Target, const Vector3f&amp; Up);
	bool OnKeyboard(int Key);
	const Vector3f&amp; GetPos() const
	const Vector3f&amp; GetTarget() const
	const Vector3f&amp; GetUp() const

private:
	Vector3f m_pos;
	Vector3f m_target;
	Vector3f m_up;
};</code></pre>
<p>Это объявление класса камеры. Он хранит 3 свойства, которые характеризуют камеру - позиция, направление и верхний вектор. Так же добавлены 2 конструктора. По умолчанию просто располагает камеру в начале координат, направляет ее в сторону уменьшения Z, а верхний вектор устремляет в "небо" (0,1,0). Но есть возможность создать камеру с указанием значений атрибутов. OnKeyboard() доставляет события клавиатуры в класс. Он возвращает значение типа bool, который указывает, воспринято ли камерой событие. Если клавиша подходит (одна из указывающих направление), возвращаемое значение -  true. Если нет - false. Таким способом можно создать цепь клиентов, которые будут получать события и останавливаться, когда один из них воспользуется этим событием.</p>
</div></article><article class="hero clearfix"><div class="col_33">
<p class="message">Camera.cpp:42</p>
</div></article><article class="hero clearfix"><div class="col_100">
<pre><code>bool Camera::OnKeyboard(int Key)
{
	bool Ret = false;
	switch (Key) {
		case GLUT_KEY_UP:{
			m_pos += (m_target * StepSize);
			Ret = true;
			} break;
		case GLUT_KEY_DOWN:{
			m_pos -= (m_target * StepSize);
			Ret = true;
			} break;
		case GLUT_KEY_LEFT:{
			Vector3f Left = m_target.Cross(m_up);
			Left.Normalize();
			Left *= StepSize;
			m_pos += Left;
			Ret = true;
			} break;
		case GLUT_KEY_RIGHT:{
			Vector3f Right = m_up.Cross(m_target);
			Right.Normalize();
			Right *= StepSize;
			m_pos += Right;
			Ret = true;
			} break;
	}
	return Ret;
}</code></pre>
<p>Эта функция двигает камеру согласно событиям клавиатуры. GLUT определил несколько макросов, обозначающих клавиши направления и этот оператор выбора основывается на них. К сожалению, тип этих макросов просто 'int', а не enum.</p>
<p>Движение вперед и назад проще. Так как это движение вдоль вектора направления, нам нужно только прибавить или вычесть вектор направления из вектора позиции. Вектор направления остается без изменений. Заметим, что прежде чем прибавлять / вычитать вектор направления, мы умножаем его на константу названую 'StepSize' (размер шага). Мы делаем это для всех направлений. Размер шага позволяет удобно изменять скорость (мы можем внести этот параметр в класс). Для удобства мы можем представить размер шага в виде единицы длины векторов (т.к. мы должны быть уверены, что вектор направления и верхний вектор являются векторами единичной длины).</p>  
<p>Перемещение в бок немного сложнее. Оно вдоль вектора, перпендикулярного плоскости, которую образуют вектор направления и вектор вверх. Плоскость делит трехмерное пространство на 2 части и у нас 2 вектора, перпендикулярных этой плоскости, и они противоположно направлены. Один мы можем назвать левым, а другой правым. Они получаются векторным произведением вектора направления и вектора вверх. В зависимости от порядка векторов, получаются соответственно левый или правый вектора. После получения нужного вектора, мы нормируем его и увеличиваем на размер шага и, наконец, прибавляем к вектору позиции (что совершит перемещение влево или вправо). И снова вектора вверх и направления остались без изменений.</p>
<p>Заметим, что в этой функции были использованы несколько новых операторов, такие как '+=' и '-=', которые были добавлены в класс Vector3f.</p>
</div></article><article class="hero clearfix"><div class="col_33">
<p class="message">main.cpp:96</p>
</div></article><article class="hero clearfix"><div class="col_100">
<pre><code>static void SpecialKeyboardCB(int Key, int x, int y){
	GameCamera.OnKeyboard(Key);
}
static void InitializeGlutCallbacks(){
	glutDisplayFunc(RenderSceneCB);
	glutIdleFunc(RenderSceneCB);
	glutSpecialFunc(SpecialKeyboardCB);
}</code></pre>
<p>Здесь мы регистрируем новую функцию обратного вызова для получения специальных событий клавиатуры. Функция отправляет клавишу и позицию курсора в момент нажатия кнопки. Мы игнорируем координаты курсора и отправляем событие в нашу камеру, которая уже объявлена как глобальная переменная.</p>
</div></article><article class="hero clearfix"><div class="col_33">
<p class="message">main.cpp:78</p>
</div></article><article class="hero clearfix"><div class="col_100">
<pre><code>p.SetCamera(GameCamera.GetPos(), GameCamera.GetTarget(), GameCamera.GetUp());</code></pre>
<p>Ранее мы передавали в класс конвейера жестко заданные вектора, характеризующие поведение камеры. Теперь эти атрибуты камеры посылаются из класса камеры.</p>